<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<meta http-equiv="Cache-Control" content="no-store, no-cache, must-revalidate, max-age=0" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="0" />
<title>Game Night â€¢ v63</title>

<style>
/* ====== STYLE (your colorful/glow theme) ====== */
:root{
  --bg:#060814;
  --bg-soft:#0b1020;

  --text:#eef4ff;
  --muted:#9fb0d0;

  --c-cyan:#22d3ee;
  --c-blue:#3b82f6;
  --c-pink:#ec4899;
  --c-green:#22c55e;
  --c-orange:#f97316;
  --c-red:#ef4444;

  --accent:var(--c-cyan);
  --danger:var(--c-red);
  --ok:var(--c-green);

  --glass: rgba(255,255,255,.06);
  --glass2: rgba(255,255,255,.025);
  --shadow: rgba(0,0,0,.45);

  --chrome-border: rgba(255,255,255,.18);
  --chrome-fill: linear-gradient(180deg,
    rgba(255,255,255,.18) 0%,
    rgba(255,255,255,.07) 14%,
    rgba(0,0,0,.22) 36%,
    rgba(255,255,255,.10) 52%,
    rgba(0,0,0,.34) 72%,
    rgba(255,255,255,.14) 100%
  );

  --title-solid:#22d3ee;
  --title-grad: linear-gradient(90deg,
    #22d3ee 0%,
    #ec4899 45%,
    #f97316 70%,
    #22c55e 100%
  );

  --active-solid:#f97316;
  --active-grad: linear-gradient(90deg,
    #f97316 0%,
    #ec4899 55%,
    #22d3ee 100%
  );

  --chrome-text: linear-gradient(135deg,
    rgba(34,211,238,1) 0%,
    rgba(59,130,246,1) 22%,
    rgba(236,72,153,1) 46%,
    rgba(249,115,22,1) 70%,
    rgba(34,197,94,1) 100%
  );
}

*{box-sizing:border-box;}
[hidden]{display:none !important;}
html,body{height:100%}
body{
  margin:0;
  font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
  background:linear-gradient(180deg,#040610,var(--bg));
  color:var(--text);
  padding-bottom:56px;
  padding-left:max(0px, env(safe-area-inset-left));
  padding-right:max(0px, env(safe-area-inset-right));
}

.footerLegal{
  position:fixed;left:0;right:0;bottom:0;z-index:20;
  display:flex;justify-content:center;
  padding:10px 12px calc(10px + env(safe-area-inset-bottom));
  pointer-events:none;
  background:linear-gradient(180deg, rgba(6,8,20,0), rgba(6,8,20,.65));
}
.footerLegal .txt{
  font-size:10px;letter-spacing:.2px;color:rgba(159,176,208,.85);
  text-align:center;text-shadow:0 2px 10px rgba(0,0,0,.45);
  max-width:980px;
}

.topbar{
  position:sticky;top:0;z-index:10;
  display:grid;grid-template-columns:1fr auto 1fr;
  align-items:center;gap:10px;
  padding:10px 12px;
  padding-top:calc(10px + env(safe-area-inset-top));
  background:var(--bg);
  border-bottom:1px solid rgba(255,255,255,.08);
}
.topActions{display:flex;align-items:center;gap:10px;min-width:96px;}
.topActions.left{justify-content:flex-start}
.topActions.right{justify-content:flex-end}

.brand{
  grid-column:2;display:flex;flex-direction:column;line-height:1.05;
  align-items:center;text-align:center;
  max-width:min(540px, 66vw);
}
.brand .t{
  font-weight:1000;font-size:20px;letter-spacing:.4px;
  text-shadow:0 2px 14px rgba(0,0,0,.55), 0 0 18px rgba(34,211,238,.10);
}
.brand .s{font-size:12px;color:var(--muted);white-space:normal;overflow-wrap:anywhere;}

.wrap{max-width:980px;margin:0 auto;padding:14px}
.card{
  background:linear-gradient(180deg,var(--glass),var(--glass2));
  border:1px solid rgba(255,255,255,.10);
  border-radius:18px;padding:14px;position:relative;
  box-shadow:0 16px 34px rgba(0,0,0,.42), 0 8px 60px rgba(0,0,0,.28);
  margin-bottom:12px;
}
.h1{font-size:26px;font-weight:1000;letter-spacing:.4px;margin:2px 0 6px;text-shadow:0 2px 14px rgba(0,0,0,.55)}
.sub{color:var(--muted);font-size:13px}
label{display:block;color:var(--muted);font-size:12px;margin-bottom:6px}

input,select{
  width:100%;
  background:rgba(7,10,20,.72);
  border:1px solid rgba(255,255,255,.14);
  color:var(--text);
  border-radius:14px;padding:12px 12px;font-size:16px;outline:none;
}
.row{display:flex;gap:10px;flex-wrap:wrap;}
.row>*{flex:1;min-width:140px}
.stack{display:flex;flex-direction:column;gap:10px}
.divider{height:1px;background:rgba(255,255,255,.10);margin:12px 0}

.toast{
  background:rgba(239,68,68,.12);
  border:1px solid rgba(239,68,68,.30);
  color:#ffd6da;border-radius:14px;padding:10px 12px;font-weight:900;margin-bottom:12px;
}

.btn{
  border:1px solid rgba(255,255,255,.14);
  background:rgba(255,255,255,.06);
  color:var(--text);
  border-radius:14px;padding:10px 12px;font-weight:900;
  box-shadow:0 6px 16px var(--shadow);
  cursor:pointer;position:relative;
}
.btn:active{transform:translateY(1px)}
.btn.ghost{background:transparent;box-shadow:none;color:var(--muted)}
.btn.ok{
  background:linear-gradient(135deg, rgba(34,197,94,.22), rgba(34,211,238,.12)) !important;
  border-color:rgba(34,197,94,.40) !important;
  box-shadow:
    0 10px 22px rgba(0,0,0,.32),
    0 0 34px rgba(34,197,94,.55),
    0 0 70px rgba(34,197,94,.28),
    inset 0 0 26px rgba(34,197,94,.22),
    inset 0 1px 0 rgba(255,255,255,.20),
    inset 0 -12px 18px rgba(0,0,0,.38);
}
.btn.danger{
  background:linear-gradient(135deg, rgba(239,68,68,.22), rgba(249,115,22,.12)) !important;
  border-color:rgba(239,68,68,.42) !important;
}
.btn:disabled{opacity:.45;cursor:not-allowed;transform:none}

.btn:not(.ghost):not(.ok):not(.danger),
.pill,.badge,.kbd{
  background:var(--chrome-fill);
  border:1px solid var(--chrome-border);
  box-shadow:
    0 10px 22px rgba(0,0,0,.32),
    inset 0 1px 0 rgba(255,255,255,.20),
    inset 0 -12px 18px rgba(0,0,0,.38);
  white-space:nowrap;
}
.btn:not(.ghost)::after,
.pill::after,
.badge::after,
.kbd::after{
  content:"";position:absolute;left:10px;right:10px;top:7px;height:38%;
  border-radius:12px;
  background:linear-gradient(180deg, rgba(255,255,255,.22), rgba(255,255,255,0));
  pointer-events:none;opacity:.85;
}

.pill{display:inline-block;padding:6px 10px;border-radius:999px;color:var(--text);font-weight:900;font-size:12px;position:relative;}
.pill.soon{background:rgba(255,255,255,.05); color:var(--muted)}
.pill[data-live="1"]{ border-color: rgba(34,211,238,.38); }
.badge{display:inline-block;padding:4px 8px;border-radius:999px;font-size:12px;font-weight:1000;color:var(--text);position:relative;}
.kbd{display:inline-block;padding:2px 8px;border-radius:999px;color:var(--muted); font-weight:900; font-size:12px;position:relative;}

@supports ((-webkit-background-clip:text) or (background-clip:text)){
  .h1, .brand .t{
    background:var(--title-grad);
    -webkit-background-clip:text;background-clip:text;
    color:transparent;
    background-size:260% 260%;
    animation:titleShift 7.5s ease-in-out infinite;
  }
}
@keyframes titleShift{
  0%{ background-position: 0% 50%; filter:saturate(1.15) contrast(1.08); }
  50%{ background-position: 100% 50%; filter:saturate(1.35) contrast(1.15); }
  100%{ background-position: 0% 50%; filter:saturate(1.15) contrast(1.08); }
}

.logoMark{
  width:44px;height:44px;border-radius:14px;
  background:
    radial-gradient(60% 60% at 30% 20%, rgba(34,211,238,.18), rgba(59,130,246,.16)),
    rgba(255,255,255,.05);
  border:1px solid rgba(255,255,255,.12);
  display:flex;align-items:center;justify-content:center;
  box-shadow:0 10px 24px rgba(0,0,0,.25);
  flex:0 0 auto;
}
.logoMark span{font-size:20px}

/* Home hero avatar: no button chrome */
.logoMark.meAvatar{background:transparent;border:none;box-shadow:none;}
.logoMark.meAvatar::after{display:none;}


.gameGrid{display:grid;grid-template-columns:1fr;gap:12px}
@media(min-width:860px){ .gameGrid{grid-template-columns:1fr 1fr;} }
.gameCard{
  background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
  border:1px solid rgba(255,255,255,.10);
  border-radius:18px;padding:14px;
  box-shadow:0 10px 26px rgba(0,0,0,.28);
}
.gameHead{display:flex;align-items:center;justify-content:space-between;gap:10px}
.gameTitle{display:flex;align-items:center;gap:10px}
.gameIcon{
  width:38px;height:38px;border-radius:14px;
  border:1px solid rgba(255,255,255,.12);
  background:
    radial-gradient(60% 60% at 30% 20%, rgba(0,0,0,0), rgba(34,211,238,.10)),
    rgba(255,255,255,.04);
  display:flex;align-items:center;justify-content:center;
  font-size:18px;
}
.gameMeta{color:var(--muted);font-size:13px;margin-top:4px}
.gameActions{display:flex;gap:10px;margin-top:10px;justify-content:center}
.gameActions .btn{flex:1;min-height:48px}

.rosterGrid{display:grid;grid-template-columns:1fr;gap:10px}
@media(min-width:860px){ .rosterGrid{grid-template-columns:1fr 1fr;} }
.rosterCard{
  display:flex;align-items:center;justify-content:space-between;gap:10px;
  padding:12px 12px;border-radius:16px;
  border:1px solid rgba(255,255,255,.10);
  background:rgba(255,255,255,.03);
}
.rosterLeft{display:flex;align-items:center;gap:10px}
.avatar{
  width:34px;height:34px;border-radius:14px;
  border:1px solid rgba(255,255,255,.12);
  background:
    radial-gradient(60% 60% at 30% 20%, rgba(34,197,94,.18), rgba(59,130,246,.10)),
    rgba(255,255,255,.04);
  display:flex;align-items:center;justify-content:center;
  font-weight:1000;color:var(--c-cyan);
  position:relative;
}
.avatar.online{
  border-color:rgba(34,197,94,.55);
  box-shadow:0 0 0 rgba(0,0,0,0), 0 0 18px rgba(34,197,94,.28);
  color:#bfffd1;
}
.avatar.online::after{
  content:"";
  position:absolute;right:-2px;bottom:-2px;
  width:9px;height:9px;border-radius:999px;
  background:rgba(34,197,94,.95);
  border:1px solid rgba(6,8,20,.9);
  box-shadow:0 0 10px rgba(34,197,94,.55);
  animation:onlineDotPulse 1.6s ease-in-out infinite;
}
@keyframes onlineDotPulse{
  0%{ transform:scale(1); filter:brightness(1); box-shadow:0 0 10px rgba(34,197,94,.45); }
  50%{transform:scale(1.35);filter:brightness(1.25);box-shadow:0 0 18px rgba(34,197,94,.75); }
  100%{transform:scale(1);  filter:brightness(1);   box-shadow:0 0 10px rgba(34,197,94,.45); }



/* ===== Optional user avatar (home only) ===== */
.rosterSub{ color:var(--muted); font-size:12px; overflow-wrap:anywhere; }


/* ===== Roster text layout (bigger name, centered) ===== */
.rosterText{
 display:flex;
 flex-direction:column;
 gap:2px;
 flex:1;
 min-width:0;
 text-align:center;
}
.rosterText .rosterName{
 font-size:16px;
 font-weight:1000;
}
.rosterText .rosterSub{
 font-size:12px;
 color:var(--muted);
 overflow-wrap:anywhere;
}

/* ===== Setup dropdown / modal picker ===== */
.modal{
  position:fixed;inset:0;z-index:9990;
  display:none;align-items:center;justify-content:center;
  padding:18px;
  background:rgba(0,0,0,.65);
  backdrop-filter: blur(6px);
}
.modal.show{display:flex !important;}
.modal[hidden]{display:none !important;}
.modal.show{display:flex;}
.modalCard{
  width:min(520px, 92vw);
  max-height:min(75vh, 640px);
  overflow:auto;
}
.pickRow{
  display:flex;align-items:center;justify-content:space-between;gap:12px;
  padding:10px 10px;border-radius:14px;
  border:1px solid rgba(255,255,255,.10);
  background:rgba(255,255,255,.03);
  cursor:pointer;
}
.pickRow:active{transform:translateY(1px)}
.pickRow .nm{font-weight:1000}
.pickRow .ck{font-weight:1000;color:var(--c-green)}
.small{font-size:12px;color:var(--muted);}

/* ===== Brand / Avatar Images ===== */
.brandLogoWrap{display:flex;justify-content:center;align-items:center;margin:12px 0 0;}
/* ===== Login art ===== */
.brandLogoWrap{
 display:flex;
 justify-content:center;
 align-items:center;
 margin:10px auto 0;
 max-width:820px;
}
.loginArtSvg{
 width:min(760px, 92vw);
 height:190px;
 border-radius:18px;
 overflow:hidden;
 position:relative;
}
.loginArtSvg::after{
 content:"";
 position:absolute; inset:0;
 background:radial-gradient(70% 60% at 50% 45%, rgba(6,8,20,0) 0%, rgba(6,8,20,0) 55%, rgba(6,8,20,.68) 100%);
 pointer-events:none;
}
@media(max-width:520px){
 .loginArtSvg{ height:150px; }
}


/* ===== Login logo (Dart Room) ===== */
.authLogoWrap{
 display:flex;
 justify-content:center;
 align-items:center;
 padding:10px 0 4px;
}
.authLogo{
 width:min(520px, 92vw);
 height:auto;
 max-height:210px;
 object-fit:contain;
 filter: saturate(1.25) brightness(1.15) hue-rotate(-10deg);
 drop-shadow: 0 0 22px rgba(34,211,238,.35);
}

</style>
</head>

<body>
<div class="topbar">
  <div class="topActions left">
    <button class="btn ghost" id="signOutBtn" type="button" style="display:none;">Sign out</button>
  </div>
  <div class="brand">
    <div class="t" id="brandTitle">Game Night</div>
    <div class="s">The Dart Room â€¢ Designed by Steveâ€™s Graphic Designs â€¢ v63</div>
  </div>
  <div class="topActions right">
    
   <button class="btn ghost" id="soundBtn" type="button" aria-label="Sound toggle">ðŸ”Š</button>
<button class="btn ghost" id="homeBtn" type="button">Home</button>
  </div>
</div>

<div class="wrap" id="app">
  <div class="card"><div class="h1">Loadingâ€¦</div><div class="sub">Starting upâ€¦</div></div>
</div>

<div class="footerLegal" aria-hidden="true">
  <div class="txt">Night Games is an official Dart Room online training tool. All rights reserved Â© Steveâ€™s Graphic Designs. â€¢ v63</div>
</div>

<!-- Player picker modal -->
<div class="modal" id="pickerModal" aria-hidden="true" hidden>
  <div class="card modalCard">
    <div class="row">
      <button class="btn ghost" id="pickerClose">Close</button>
      <button class="btn ok" id="pickerDone">Done</button>
    </div>
    <div class="divider"></div>
    <div class="h1" style="font-size:18px;margin:0">Pick players</div>
    <div class="sub">Tap names to toggle. (Emails are hidden; app still uses them internally.)</div>
    <div class="divider"></div>
    <div class="stack" id="pickerList"></div>
  </div>
</div>

<script src="https://www.gstatic.com/firebasejs/10.12.5/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.12.5/firebase-analytics-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.12.5/firebase-firestore-compat.js"></script>
<script>
/* ========= Firebase modular API shims (Compat) =========
   This lets the rest of the app use the v9+ modular-style helpers
   without relying on <script type="module"> imports (works on GitHub Pages + local file open).
*/
function initializeApp(config){ return firebase.initializeApp(config); }
function getAnalytics(app){ try{ return firebase.analytics(app); }catch(_){ return null; } }
function getFirestore(app){ return firebase.firestore(app); }

function collection(db, name){ return db.collection(name); }

function doc(refOrDb, colOrId, maybeId){
  // doc(db,"players","id") OR doc(collectionRef,"id")
  if(refOrDb && typeof refOrDb.collection === "function" && typeof colOrId === "string" && typeof maybeId === "string"){
    return refOrDb.collection(colOrId).doc(maybeId);
  }
  if(refOrDb && typeof refOrDb.doc === "function" && typeof colOrId === "string" && maybeId == null){
    return refOrDb.doc(colOrId);
  }
  throw new Error("doc() shim: unsupported arguments");
}

function where(field, op, value){ return {t:"where", field, op, value}; }
function orderBy(field, dir){ return {t:"orderBy", field, dir}; }
function limit(n){ return {t:"limit", n}; }
function query(ref, ...clauses){ return {ref, clauses}; }
function serverTimestamp(){ return firebase.firestore.FieldValue.serverTimestamp(); }

async function getDoc(docRef){
  const snap = await docRef.get();
  return {
    exists: ()=> snap.exists,
    data: ()=> snap.data()
  };
}

async function setDoc(docRef, data, options){
  return docRef.set(data, options);
}

async function updateDoc(docRef, data){
  return docRef.update(data);
}

async function getDocs(q){
  const ref = (q && q.ref) ? q.ref : q;
  const clauses = (q && q.clauses) ? q.clauses : [];
  let built = ref;
  for(const c of clauses){
    if(!c) continue;
    if(c.t==="where") built = built.where(c.field, c.op, c.value);
    else if(c.t==="orderBy") built = built.orderBy(c.field, c.dir);
    else if(c.t==="limit") built = built.limit(c.n);
  }
  const snap = await built.get();
  return {
    empty: snap.empty,
    docs: snap.docs.map(d=>({ id:d.id, data:()=>d.data() }))
  };
}

function onSnapshot(ref, cb){
  // Return unsubscribe function
  return ref.onSnapshot(snap=>{
    cb({
      data: ()=> snap.data()
    });
  });
}
</script>
<script>
/* ========= Firebase (CDN modules) ========= */

/* ========= CONFIG (yours) ========= */
const firebaseConfig = {
  apiKey: "AIzaSyC0sdB54z0G73P3epW6GmHqgYvESFcqgTo",
  authDomain: "gamenightdarts-e7601.firebaseapp.com",
  projectId: "gamenightdarts-e7601",
  storageBucket: "gamenightdarts-e7601.firebasestorage.app",
  messagingSenderId: "270045452251",
  appId: "1:270045452251:web:5a4a661140a60780e939fe",
  measurementId: "G-M60TDFYBW0"
};

const fbApp = initializeApp(firebaseConfig);
try { getAnalytics(fbApp); } catch {}
const db = getFirestore(fbApp);

/* ========= Helpers ========= */
const appEl = document.getElementById("app");
const homeBtn = document.getElementById("homeBtn");
const signOutBtn = document.getElementById("signOutBtn");
const brandTitle = document.getElementById("brandTitle");

function esc(s){ return String(s==null?"":s).replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;"); }
function normEmail(e){ return String(e==null?"":e).trim().toLowerCase(); }

// Returns a data URI for a player if we have a custom avatar for them.

function now(){ return Date.now(); }
function fmt(ts){ try{ return new Date(ts).toLocaleString(); }catch{ return ""; } }

// ===== Sound system (tiny synth; no external files) =====
let soundEnabled = true;
try{
  const v = localStorage.getItem("gn_sound");
  if(v === "0") soundEnabled = false;
}catch{}

let __audioCtx = null;
const MASTER_GAIN = 3.2; // phone-friendly

function ensureAudio(){
  if(__audioCtx) return __audioCtx;
  try{ __audioCtx = new (window.AudioContext || window.webkitAudioContext)(); }catch{ __audioCtx = null; }
  return __audioCtx;
}

let __audioUnlocked = false;
function unlockAudio(){
  if(__audioUnlocked) return;
  const ctx = ensureAudio();
  if(!ctx) return;
  try{ if(ctx.state === "suspended") ctx.resume(); }catch{}
  // silent tick to fully unlock (iOS/Safari)
  try{
    const o = ctx.createOscillator();
    const g = ctx.createGain();
    g.gain.value = 0.0002;
    o.frequency.value = 440;
    o.connect(g); g.connect(ctx.destination);
    o.start(); o.stop(ctx.currentTime + 0.02);
  }catch{}
  __audioUnlocked = true;
}
window.addEventListener("pointerdown", unlockAudio, {passive:true});
window.addEventListener("touchstart", unlockAudio, {passive:true});

function playBeep(kind){
  unlockAudio();
  if(!soundEnabled) return;
  const ctx = ensureAudio();
  if(!ctx) return;
  try{ if(ctx.state === "suspended") ctx.resume(); }catch{}

  const _nowMs = Date.now();
  window.__lastBeepAt = window.__lastBeepAt || 0;
  if((_nowMs - window.__lastBeepAt) < 70) return;
  window.__lastBeepAt = _nowMs;

  const t0 = ctx.currentTime;

  const preset = (()=>{
    switch(kind){
      case "ok":     return {type:"triangle", f:523.25, dur:0.14, gain:0.85}; // C5
      case "danger": return {type:"sawtooth", f:220.00, dur:0.16, gain:0.85}; // A3
      case "hit":    return {type:"sine",     f:659.25, dur:0.13, gain:0.84}; // E5
      case "miss":   return {type:"sine",     f:196.00, dur:0.16, gain:0.85}; // G3
      case "back":   return {type:"triangle", f:329.63, dur:0.10, gain:0.85}; // E4
      case "nav":    return {type:"triangle", f:392.00, dur:0.10, gain:0.85}; // G4
      case "toggle": return {type:"square",   f:784.00, dur:0.09, gain:0.85}; // G5
      default:       return {type:"triangle", f:440.00, dur:0.10, gain:0.85}; // A4
    }
  })();

  const o = ctx.createOscillator();
  const g = ctx.createGain();
  o.type = preset.type;
  o.frequency.setValueAtTime(preset.f, t0);

  g.gain.setValueAtTime(0.0001, t0);
  const g1 = Math.min(0.95, preset.gain * MASTER_GAIN);
  g.gain.exponentialRampToValueAtTime(g1, t0 + 0.015);
  g.gain.exponentialRampToValueAtTime(0.0001, t0 + preset.dur);

  o.connect(g); g.connect(ctx.destination);
  o.start(t0);
  o.stop(t0 + preset.dur + 0.02);
}

function setSoundEnabled(on){
  soundEnabled = !!on;
  try{ localStorage.setItem("gn_sound", soundEnabled ? "1" : "0"); }catch{}
  const soundBtn = document.getElementById("soundBtn");
  if(soundBtn){
    soundBtn.textContent = soundEnabled ? "ðŸ”Š" : "ðŸ”ˆ";
    soundBtn.setAttribute("aria-label", soundEnabled ? "Sound on" : "Sound off");
  }
}

// One global click handler for UI sounds (gameplay buttons get "hit/miss")
document.addEventListener("click", (ev)=>{
  const btn = ev.target && ev.target.closest ? ev.target.closest("button") : null;
  if(!btn || btn.disabled) return;

  if(btn.dataset && btn.dataset.nosound === "1") return;
  if(btn.id === "soundBtn") return;

  const id = String(btn.id||"").toLowerCase();
  const txt = String(btn.textContent||"").trim().toLowerCase();

  if(btn.classList && btn.classList.contains("danger")) return playBeep("danger");
  if(btn.classList && btn.classList.contains("ok")) return playBeep("ok");

  // gameplay
  if(btn.classList && btn.classList.contains("hitBtn")){
    if(id.includes("miss") || txt.includes("miss")) return playBeep("miss");
    return playBeep("hit");
  }
  if(btn.classList && btn.classList.contains("kAttackBtn")) return playBeep("hit");

  if(id.includes("back") || txt === "back" || txt === "undo") return playBeep("back");
  if(btn.classList && btn.classList.contains("ghost")) return playBeep("nav");

  return playBeep("click");
}, {capture:true});
function uuid(){ return (crypto && crypto.randomUUID) ? crypto.randomUUID() : (Math.random().toString(16).slice(2) + "-" + Date.now()); }

function setHTML(html){
  appEl.innerHTML = html;
  try{ window.scrollTo({top:0,left:0,behavior:"instant"}); }catch{ window.scrollTo(0,0); }
}

/* ========= Firestore collections ========= */
const C_PLAYERS = "players";
const C_STATS   = "stats";
const C_HISTORY = "history";
const C_ROOMS   = "rooms";
const C_PRES    = "presence";

/* ========= Players ========= */
async function getPlayers(){
  const snap = await getDocs(query(collection(db,C_PLAYERS), orderBy("name")));
  return snap.docs.map(d=>d.data());
}
async function upsertPlayer(name,email){
  const e = normEmail(email);
  await setDoc(doc(db,C_PLAYERS,e), { name, email:e, updatedAt:serverTimestamp() }, {merge:true});
}
async function signInEmail(email){
  const e = normEmail(email);
  const ref = doc(db,C_PLAYERS,e);
  const snap = await getDoc(ref);
  if(!snap.exists()) return null;
  return snap.data();
}
async function signUpEmail(name,email){
  const e = normEmail(email);
  await setDoc(doc(db,C_PLAYERS,e), { name, email:e, createdAt:serverTimestamp() });
  return {name,email:e};
}

/* ========= Presence (online dots) =========
   Simple, reliable Firestore heartbeat:
   - Each client updates presence/<email> { lastSeen: serverTimestamp(), name }
   - Everyone considers "online" if lastSeen within 70 seconds.
*/
let presUnsub = null;
let presTick = null;
let presCache = {}; // email -> lastSeenMs
function isOnline(email){
  const ms = presCache[normEmail(email)];
  if(!ms) return false;
  return (Date.now() - ms) < 70_000;
}

function startPresence(email, name){
  const e = normEmail(email);
  stopPresence();
  const ref = doc(db, C_PRES, e);

  const ping = async()=>{
    try{
      await setDoc(ref, { email:e, name:name||"", lastSeen: serverTimestamp() }, {merge:true});
    }catch(e){ /* ignore */ }
  };

  ping();
  presTick = setInterval(ping, 25_000);

  // Subscribe to all presence docs (cheap at small scale)
  presUnsub = onSnapshot(collection(db, C_PRES), (snap)=>{
    const out = {};
    snap.forEach(d=>{
      const data = d.data() || {};
      const em = normEmail(data.email || d.id);
      const ls = data.lastSeen;
      let ms = null;
      try{
        // Firestore Timestamp -> ms (if available)
        ms = ls && typeof ls.toMillis === "function" ? ls.toMillis() : null;
      }catch{}
      if(ms) out[em] = ms;
    });
    presCache = out;
    // Don't re-render entire app every tick; only when on screens that show roster
    if(screen==="home" || screen==="stats" || screen==="game.setup") requestRender("presence");
  });

  // Attempt best-effort final ping
  window.addEventListener("beforeunload", ()=>{ try{ clearInterval(presTick); }catch{} });
}
function stopPresence(){
  try{ if(presUnsub) presUnsub(); }catch{}
  presUnsub = null;
  if(presTick) clearInterval(presTick);
  presTick = null;
}

/* ========= Rooms (multiplayer lock + auto-join) =========
   - Host creates room with gameId + players array.
   - Only listed players can join.
   - When opponent opens the same game, they auto-join the waiting room.
   - Match state is synced to room.matchData (per action).
*/
async function createRoom(gameId, playersEmails){
  const id = uuid();
  await setDoc(doc(db, C_ROOMS, id), {
    gameId,
    players: playersEmails.map(normEmail),
    state: "waiting",
    createdAt: serverTimestamp(),
    hostEmail: normEmail(meUser.email),
    matchData: null,
    rev: 0,
    updatedBy: null
  });
  return id;
}

async function findWaitingRoomForPlayer(gameId, email){
  const e = normEmail(email);
  const snap = await getDocs(query(
    collection(db, C_ROOMS),
    where("gameId","==",gameId),
    where("state","in",["waiting","active"]),
    where("players","array-contains",e),
    orderBy("createdAt","desc"),
    limit(1)
  ));
  if(snap.empty) return null;
  return snap.docs[0].id;
}

async function joinRoom(roomId){
  const ref = doc(db, C_ROOMS, roomId);
  const snap = await getDoc(ref);
  if(!snap.exists()) throw new Error("Room not found.");
  const data = snap.data();
  const e = normEmail(meUser.email);
  if(!Array.isArray(data.players) || !data.players.includes(e)) throw new Error("Not allowed in this room.");
  if(data.state==="waiting"){
    await updateDoc(ref, { state:"active" });
  }
}

let roomUnsub = null;
async function saveMatchState(roomId, match){
  const ref = doc(db, C_ROOMS, roomId);
  const payload = structuredClone(match);
  const nextRev = (match._rev||0) + 1;
  match._rev = nextRev;
  await updateDoc(ref, { matchData: payload, rev: nextRev, updatedBy: normEmail(meUser.email) });
}
function listenMatchState(roomId, cb){
  const ref = doc(db, C_ROOMS, roomId);
  if(roomUnsub) try{ roomUnsub(); }catch{}
  roomUnsub = onSnapshot(ref, (snap)=>{
    if(!snap.exists()) return;
    const data = snap.data() || {};
    cb(data);
  });
  return ()=>{ if(roomUnsub) roomUnsub(); roomUnsub=null; };
}

/* ========= History & Stats (stored online) ========= */
async function saveHistoryEntry(entry){
  const id = uuid();
  await setDoc(doc(db, C_HISTORY, id), entry);
}
async function getHistory(email){
  const e = normEmail(email);
  const snap = await getDocs(query(
    collection(db, C_HISTORY),
    where("players","array-contains",e),
    orderBy("endedAt","desc"),
    limit(50)
  ));
  return snap.docs.map(d=>d.data());
}

async function getStatsDoc(email){
  const ref = doc(db, C_STATS, normEmail(email));
  const snap = await getDoc(ref);
  return snap.exists()?snap.data():{};
}
async function saveStatsDoc(email,data){
  await setDoc(doc(db, C_STATS, normEmail(email)), data, {merge:true});
}

/* ========= Dangerous ops (optional UI uses them) ========= */
async function resetStatsAll(email){
  await setDoc(doc(db, C_STATS, normEmail(email)), {games:{}, updatedAt:now()}, {merge:true});
}
async function resetStatsGame(email, gameId){
  const stats = await getStatsDoc(email);
  const games = stats.games || {};
  delete games[gameId];
  await saveStatsDoc(email, {games, updatedAt:now()});
}
async function deleteHistoryForPlayer(email){
  // For safety, this only clears the local "history" view is not per-device here.
  // Keeping it no-op to avoid mass deletes accidentally.
  alert("History delete is disabled in this build to prevent accidental data loss.");
}
async function deletePlayerAndData(email){
  const e = normEmail(email);
  const batch = writeBatch(db);
  batch.delete(doc(db, C_PLAYERS, e));
  batch.delete(doc(db, C_STATS, e));
  batch.delete(doc(db, C_PRES, e));
  await batch.commit();
  alert("Player deleted. (History entries remain.)");
}

/* ========= UI State ========= */
let toastMsg = "";
let screen = "auth";
let meUser = null;

let activeGameId = null;
let match = null;

let roomId = null;          // current multiplayer room (optional)
let roomHost = false;       // am I host of room?
let roomSynced = false;     // have we received initial matchData?

const Games = [
  {id:"shanghai", name:"Shanghai", icon:"ðŸŽ¯", active:true,  tagline:"20 â†’ 15 â†’ Bull"},
  {id:"killer",   name:"Killer",   icon:"ðŸ”¥", active:true,  tagline:"Claim a number â€¢ Hit doubles"},
  {id:"around",   name:"Around the World", icon:"ðŸŒ", active:true,  tagline:"1 â†’ 20 â†’ Bull â€¢ Singles/Doubles/Triples"},
  {id:"halve",    name:"Halve-It", icon:"âž—", active:false, tagline:"Coming soon"},
  {id:"baseball", name:"Baseball", icon:"âš¾", active:false, tagline:"Coming soon"},
];
const getGame = id => Games.find(g=>g.id===id) || null;
const MAX_PLAYERS = 4;

/* ========= Player picker (replaces iOS-broken multi-select) ========= */
const pickerModal = document.getElementById("pickerModal");
const pickerList  = document.getElementById("pickerList");
const pickerClose = document.getElementById("pickerClose");
const pickerDone  = document.getElementById("pickerDone");

let setupPlayersAll = [];           // players from DB
let setupSelectedEmails = [];       // selected emails
let setupWantedCount = 2;           // number of players

function openPicker(title, items, selectedSet, onToggle){
 const modal=document.getElementById("pickerModal");
 const titleEl=document.getElementById("pickerTitle");
 const listEl=document.getElementById("playerPicker");
 if(!modal||!titleEl||!listEl) return;

 // Safety: keep picker hidden unless explicitly opened (even if CSS fails to load)
 modal.hidden = false;

 titleEl.textContent=title||"Pick players";
 listEl.innerHTML = (items||[]).map(it=>{
   const checked = selectedSet && selectedSet.has(it.value);
   return `<div class="pickerItem ${checked?'on':''}" data-val="${esc(it.value)}">
     <span class="chk">${checked?'âœ“':''}</span>
     <span class="nm">${esc(it.label||it.value)}</span>
     ${it.sub?`<span class="sub">${esc(it.sub)}</span>`:''}
   </div>`;
 }).join("");

 // click binding
 Array.from(listEl.querySelectorAll(".pickerItem")).forEach(el=>{
   el.onclick=()=>{
     const val=el.getAttribute("data-val");
     if(!val) return;
     try{ onToggle && onToggle(val); }catch(_){}
     // refresh display
     const checked = selectedSet && selectedSet.has(val);
     if(checked){ el.classList.add("on"); el.querySelector(".chk").textContent="âœ“"; }
     else{ el.classList.remove("on"); el.querySelector(".chk").textContent=""; }
   };
 });

 modal.classList.add("show");

 // Close buttons
 document.getElementById("pickerClose").onclick=()=>{ try{ playBeep("back"); }catch{} closePicker(); };
 document.getElementById("pickerDone").onclick=()=>{ try{ playBeep("ok"); }catch{} closePicker(); };
}
function closePicker(){
 const modal=document.getElementById("pickerModal");
 if(modal){
   modal.classList.remove("show");
   modal.hidden = true;
 }
}

/* ========= Games logic (kept close to your original) ========= */
const BOARD_NUMS=[20,1,18,4,13,6,10,15,2,17,3,19,7,16,8,11,14,9,12,5];

function polar(cx,cy,r,deg){
  const rad=(deg-90)*Math.PI/180;
  return {x:cx+r*Math.cos(rad), y:cy+r*Math.sin(rad)};
}
function arcWedgePath(cx,cy,r0,r1,a0,a1){
  const p1=polar(cx,cy,r1,a0), p2=polar(cx,cy,r1,a1);
  const p3=polar(cx,cy,r0,a1), p4=polar(cx,cy,r0,a0);
  const large=(a1-a0)>180?1:0;
  const f=n=>(Math.round(n*1000)/1000).toFixed(3);
  return `M ${f(p1.x)} ${f(p1.y)} A ${r1} ${r1} 0 ${large} 1 ${f(p2.x)} ${f(p2.y)} L ${f(p3.x)} ${f(p3.y)} A ${r0} ${r0} 0 ${large} 0 ${f(p4.x)} ${f(p4.y)} Z`;
}
function dartboardSVG(activeTarget){
  const cx=100,cy=100;
  const outer=80, rDoubleOuter=74, rDoubleInner=66, rTripleOuter=48, rTripleInner=40, rSingleInner=12;
  const seg=360/20;
  const rot=-seg/2;

  function ringWedges(r0,r1,fillA,fillB){
    let out="";
    for(let i=0;i<20;i++){
      const a0=i*seg+rot+0.8;
      const a1=(i+1)*seg+rot-0.8;
      out+=`<path d="${arcWedgePath(cx,cy,r0,r1,a0,a1)}" fill="${i%2===0?fillA:fillB}" opacity="0.95"/>`;
    }
    return out;
  }

  // Active target overlay (simplified from your build)
  let activeOverlay="";
  if(typeof activeTarget === "number"){
    const idx = BOARD_NUMS.indexOf(activeTarget);
    if(idx>=0){
      const a0=idx*seg+rot+0.6;
      const a1=(idx+1)*seg+rot-0.6;
      activeOverlay += `<path d="${arcWedgePath(cx,cy,rSingleInner,rDoubleOuter,a0,a1)}"
        fill="rgba(34,211,238,.14)" stroke="rgba(34,211,238,.75)" stroke-width="6.5" filter="url(#glow)" />`;
    }
  }else if(activeTarget === "B"){
    activeOverlay += `
      <circle cx="100" cy="100" r="14.5" fill="rgba(34,211,238,.22)" stroke="rgba(34,211,238,.98)" stroke-width="3.0" filter="url(#glow)"/>
      <circle cx="100" cy="100" r="7.6"  fill="rgba(34,197,94,.16)" stroke="rgba(255,255,255,.92)" stroke-width="2.6" filter="url(#glow)"/>
    `;
  }

  let numText="";
  for(let i=0;i<20;i++){
    const ang=i*seg+rot+seg/2;
    const p=polar(cx,cy,90,ang);
    const n=BOARD_NUMS[i];
    const isActive=(typeof activeTarget==="number" && n===activeTarget);
    numText += isActive
      ? `<text x="${p.x.toFixed(2)}" y="${p.y.toFixed(2)}" text-anchor="middle" dominant-baseline="middle"
          font-size="10.2" fill="#22d3ee" font-weight="1000"
          style="paint-order:stroke;stroke:#ffffff;stroke-width:2.6px;filter:url(#glow)">${n}</text>`
      : `<text x="${p.x.toFixed(2)}" y="${p.y.toFixed(2)}" text-anchor="middle" dominant-baseline="middle"
          font-size="8.5" fill="#dfe9ff" font-weight="900"
          style="paint-order:stroke;stroke:#07101d;stroke-width:2px">${n}</text>`;
  }

  return `<svg viewBox="0 0 200 200" width="100%" height="100%" preserveAspectRatio="xMidYMid meet">
    <defs>
      <radialGradient id="bgG" cx="50%" cy="42%" r="65%">
        <stop offset="0%" stop-color="#1a2a4a"/>
        <stop offset="55%" stop-color="#0b1325"/>
        <stop offset="100%" stop-color="#040814"/>
      </radialGradient>
      <filter id="glow" x="-30%" y="-30%" width="160%" height="160%">
        <feGaussianBlur stdDeviation="4.8" result="b"/>
        <feColorMatrix in="b" type="matrix"
          values="0 0 0 0 0.18  0 0 0 0 0.92  0 0 0 0 1.00  0 0 0 1.0 0" result="c"/>
        <feMerge><feMergeNode in="c"/><feMergeNode in="SourceGraphic"/></feMerge>
      </filter>
    </defs>
    <circle cx="100" cy="100" r="${outer}" fill="url(#bgG)" stroke="#2a3f5f" stroke-width="2"/>
    ${ringWedges(rTripleOuter,rDoubleInner,"#0b1220","#1a2338")}
    ${ringWedges(rTripleInner,rTripleOuter,"#2aa84a","#c63a3a")}
    ${ringWedges(rDoubleInner,rDoubleOuter,"#2aa84a","#c63a3a")}
    ${ringWedges(rSingleInner,rTripleInner,"#1a2338","#0b1220")}
    ${activeOverlay}
    <circle cx="100" cy="100" r="11.5" fill="#2aa84a" stroke="#1b2b42" stroke-width="2"/>
    <circle cx="100" cy="100" r="5.3" fill="#c63a3a" stroke="#1b2b42" stroke-width="1.5"/>
    ${numText}
  </svg>`;
}

/* ===== Turn-name swipe animation (kept from your build idea) ===== */
let _turnNameCache = {};
function turnNameHTML(name){
  const nm = esc(name||"");
  return `<div style="font-weight:1000;font-size:26px;text-align:center">
    <span style="color:var(--c-cyan);text-shadow:0 0 14px rgba(34,211,238,.65)">âŸ¦</span>
    <span style="background:var(--active-grad);-webkit-background-clip:text;background-clip:text;color:transparent;background-size:240% 240%;animation:titleShift 6.5s ease-in-out infinite;text-shadow:none">${nm}</span>
    <span style="color:var(--c-cyan);text-shadow:0 0 14px rgba(34,211,238,.65)">âŸ§</span>
  </div>`;
}
function animateTurnName(gameId, name){
  const box=document.getElementById("turnNameBox");
  if(!box) return;
  const prev=_turnNameCache[gameId];
  _turnNameCache[gameId]=name;
  if(!prev || prev===name){ box.innerHTML = turnNameHTML(name); return; }
  box.innerHTML = `
    <div class="turnOld">${turnNameHTML(prev)}</div>
    <div class="turnNew">${turnNameHTML(name)}</div>
  `;
  const oldWrap = box.querySelector(".turnOld");
  const newWrap = box.querySelector(".turnNew");
  try{
    oldWrap.animate([{transform:"translateX(0%)",opacity:1},{transform:"translateX(-140%)",opacity:0.2}],{duration:320,easing:"cubic-bezier(.2,.8,.2,1)"});
    newWrap.animate([{transform:"translateX(140%)",opacity:0.2},{transform:"translateX(0%)",opacity:1}],{duration:320,easing:"cubic-bezier(.2,.8,.2,1)"}).onfinish=()=>{ box.innerHTML = turnNameHTML(name); };
  }catch{ box.innerHTML = turnNameHTML(name); }
}

function playerStripHTML(players, activeIndex, extraLineFn){
  try{
    return `<div style="display:flex;gap:10px;justify-content:center;flex-wrap:wrap;padding:6px 0 2px">` +
      (players||[]).map((p,i)=>{
        const act=(i===activeIndex);
        const extra=extraLineFn?(extraLineFn(p,i)||""):"";
        return `<div style="min-width:140px;max-width:min(320px,90vw);flex:1;border-radius:16px;border:1px solid rgba(255,255,255,.10);background:rgba(255,255,255,.03);padding:10px 12px;text-align:center;${act?'border-color:rgba(34,197,94,.55);box-shadow:0 0 28px rgba(34,197,94,.22);':''}">
          <div style="font-weight:1000;font-size:15px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis">${esc(p.name||"")}</div>
          <div class="sub" style="margin-top:2px">${act?"NOW THROWING":"&nbsp;"}</div>
          ${extra?`<div class="small" style="margin-top:4px">${extra}</div>`:""}
        </div>`;
      }).join("") + `</div>`;
  }catch{ return ""; }
}

/* ========= Snapshot undo ========= */
function pushSnap(m){ m.snaps=m.snaps||[]; m.snaps.push(JSON.stringify(m)); if(m.snaps.length>80) m.snaps.shift(); }
function popSnap(m){
  if(!m || !m.snaps || m.snaps.length<2) return m;
  m.snaps.pop();
  const prev=m.snaps.pop();
  try{return JSON.parse(prev);}catch{return m;}
}

/* ========= Games: Shanghai / Killer / Around (core play logic from your snippet) ========= */
const ShanghaiGame=(()=>{
  const TARGETS=[20,19,18,17,16,15,"B"];
  const pts=hit=>hit==="T"?3:hit==="D"?2:hit==="S"?1:0;

  function initMatch(selectedPlayers){
    const m={
      gameId:"shanghai",
      players:selectedPlayers.map(p=>({name:p.name,email:p.email,total:0})),
      startedAt:now(), endedAt:null,
      turnIndex:0, targetIndex:0, dartInTurn:0,
      finished:false, grid:{}, snaps:[], _saved:false, _rev:0
    };
    m.players.forEach(p=>{
      m.grid[p.email]={};
      TARGETS.forEach(t=>{ m.grid[p.email][String(t)]={throws:[],points:0}; });
    });
    pushSnap(m);
    return m;
  }

  function addThrow(m, hit){
    if(!m||m.finished) return;
    const player=m.players[m.turnIndex];
    const targetKey=String(TARGETS[m.targetIndex]);
    const cell=m.grid[player.email][targetKey];
    cell.throws.push(hit);
    cell.points+=pts(hit);
    player.total+=pts(hit);

    m.dartInTurn++;
    if(m.dartInTurn>=3){
      m.dartInTurn=0;
      m.turnIndex=(m.turnIndex+1)%m.players.length;
      if(m.turnIndex===0) m.targetIndex++;
    }
    if(m.targetIndex>=TARGETS.length){
      m.finished=true; m.endedAt=now();
    }
  }

  async function saveFinish(ctx){
    const m=ctx.match;
    if(!m.finished||m._saved) return;
    m._saved=true;

    const summary=m.players.slice().sort((a,b)=>b.total-a.total)
      .map(p=>`${p.name}: ${p.total}`).join(" | ");

    await saveHistoryEntry({
      gameId:"shanghai", gameName:"Shanghai",
      startedAt:m.startedAt, endedAt:m.endedAt,
      players:m.players.map(p=>p.email),
      summary,
      meta:{targets:TARGETS}
    });

    const stats=await getStatsDoc(ctx.meUser.email);
    const games=stats.games||{};
    const g=games.shanghai||{};
    const played=(g.played||0)+1;

    const meRow=m.players.find(p=>p.email===ctx.meUser.email);
    const myScore=meRow?meRow.total:0;
    const points=(g.points||0)+myScore;
    const best=Math.max(g.best||0,myScore);

    await saveStatsDoc(ctx.meUser.email,{
      games:{...games, shanghai:{...g, played, points, best, lastPlayedAt:m.endedAt||now()}},
      updatedAt:now()
    });
  }

  function renderPlay(ctx){
    const m=ctx.match;
    const t=TARGETS[m.targetIndex];

    let thead=`<tr><th>Target</th>`;
    for(const p of m.players){ thead+=`<th>${esc(p.name)}<div class="small">${p.total} pts</div></th>`; }
    thead+=`</tr>`;

    let tbody="";
    for(const target of TARGETS){
      const key=String(target);
      tbody+=`<tr><td><span class="badge">${esc(target==="B"?"BULL":target)}</span></td>`;
      for(const p of m.players){
        const cell=m.grid[p.email][key];
        const txt=cell.throws.length?cell.throws.join(" "):"â€”";
        const cls=String(t)===key?` style="outline:2px solid rgba(34,211,238,.22);background:rgba(34,211,238,.06);border-radius:10px"`:"";
        tbody+=`<td ${cls}>${esc(txt)}<div class="small">${cell.points}</div></td>`;
      }
      tbody+=`</tr>`;
    }

    return `
      <div class="card"><div class="row">
        <button class="btn ghost" id="backToSetup">Back</button>
        <button class="btn danger" id="resetBtn">Reset</button>
      </div></div>

      <div class="card">
        <div class="row" style="align-items:center">
          <div><span class="pill">Shanghai</span> <span class="pill" data-live="1">Live</span></div>
          <div style="text-align:right" class="sub">${m.finished?"Ended":"In progress"}</div>
        </div>

        ${m.finished ? "" : `<div id="turnNameBox" style="margin-top:10px">${turnNameHTML(m.players[m.turnIndex]?.name||"")}</div>`}
        <div class="sub" style="text-align:center;margin-top:6px">Target: <b>${esc(t==="B"?"BULL":t)}</b> â€¢ Dart <b>${m.dartInTurn+1}</b>/3</div>
        <div class="divider"></div>
        <div style="display:flex;justify-content:center">${dartboardSVG(t==="B"?"B":t)}</div>
        ${playerStripHTML(m.players,m.turnIndex,(p)=>"Score: <b>"+esc(p.total)+"</b>")}
        <div class="divider"></div>

        <div class="row">
          <button class="btn" id="hitT" ${m.finished?"disabled":""}>TRIPLE</button>
          <button class="btn" id="hitS" ${m.finished?"disabled":""}>SINGLE</button>
          <button class="btn" id="hitD" ${m.finished?"disabled":""}>DOUBLE</button>
          <button class="btn danger" id="hitM" ${m.finished?"disabled":""}>MISS</button>
          <button class="btn ghost" id="undoBtn">UNDO</button>
        </div>
      </div>

      <div class="card">
        <div class="pill">Round table</div>
        <div class="divider"></div>
        <div style="overflow:auto;border-radius:16px;border:1px solid rgba(255,255,255,.10)">
          <table style="width:100%;border-collapse:separate;border-spacing:0">
            <thead style="background:rgba(7,10,20,.82)">${thead}</thead>
            <tbody>${tbody}</tbody>
          </table>
        </div>
      </div>
    `;
  }

  function bindPlay(ctx){
    try{ animateTurnName("shanghai", ctx.match.players[ctx.match.turnIndex].name); }catch{}
    function onHit(h){
      const m=ctx.match;
      if(m.finished) return;
      pushSnap(m);
      addThrow(m,h);
      render();
      // sync multiplayer
      if(roomId) saveMatchState(roomId, m).catch(()=>{});
      if(m.finished){
        saveFinish(ctx).catch(()=>{});
      }
    }
    document.getElementById("hitT").onclick=()=>onHit("T");
    document.getElementById("hitS").onclick=()=>onHit("S");
    document.getElementById("hitD").onclick=()=>onHit("D");
    document.getElementById("hitM").onclick=()=>onHit("M");
    document.getElementById("undoBtn").onclick=()=>{ match=popSnap(ctx.match); render(); if(roomId) saveMatchState(roomId, match).catch(()=>{}); };

    document.getElementById("resetBtn").onclick=()=>{
      const pls=ctx.match.players.map(p=>({name:p.name,email:p.email}));
      match=initMatch(pls); render(); if(roomId) saveMatchState(roomId, match).catch(()=>{});
    };
    document.getElementById("backToSetup").onclick=()=>{
      match=null; roomId=null; screen="game.setup"; render();
      if(roomUnsub) try{ roomUnsub(); }catch{}
    };
  }

  return {initMatch, renderPlay, bindPlay};
})();

const KillerGame = (() => {
  const MAX_LIVES = 3;
  function initMatch(selectedPlayers){
    return {
      gameId:"killer",
      phase:"claim",
      claimIndex:0,
      players: selectedPlayers.map(p=>({
        name:p.name,email:p.email,number:null,lives:MAX_LIVES,killer:false,out:false
      })),
      turnIndex:0,dartInTurn:0,finished:false,winner:null,
      startedAt:now(),endedAt:null,snaps:[],_saved:false,_rev:0
    };
  }
  function nextAliveIndex(m, from){
    for(let step=1; step<=m.players.length; step++){
      const i=(from+step)%m.players.length;
      if(!m.players[i].out) return i;
    }
    return from;
  }
  function checkWinner(m){
    const alive=m.players.filter(p=>!p.out);
    if(alive.length===1){
      m.finished=true; m.winner=alive[0]; m.endedAt=now();
    }
  }
  async function saveFinish(ctx){
    const m=ctx.match;
    if(!m.finished || m._saved) return;
    m._saved=true;

    const winnerName=(m.winner && m.winner.name) || "Unknown";
    const summary = `ðŸ† ${winnerName} wins â€¢ ` + m.players.map(p=>`${p.name}${p.out?" (OUT)":""}`).join(" | ");

    await saveHistoryEntry({
      gameId:"killer", gameName:"Killer",
      startedAt:m.startedAt, endedAt:m.endedAt,
      players:m.players.map(p=>p.email),
      summary,
      meta:{ winnerEmail:(m.winner&&m.winner.email)||null, numbers:m.players.map(p=>({email:p.email, number:p.number})) }
    });

    const stats=await getStatsDoc(ctx.meUser.email);
    const games=stats.games||{};
    const g=games.killer||{};
    const played=(g.played||0)+1;
    const iWon = (((m.winner && m.winner.email) === ctx.meUser.email));
    const wins = (g.wins||0) + (iWon?1:0);

    await saveStatsDoc(ctx.meUser.email,{ games:{...games, killer:{...g, played, wins, lastPlayedAt:m.endedAt||now()}}, updatedAt:now() });
  }
  function heartsHTML(n){
    const count=Math.max(0, Number(n||0));
    if(!count) return "";
    return Array.from({length:count}, ()=>`<span style="color:var(--danger);font-weight:1000">â™¥</span>`).join("");
  }

  function renderPlay(ctx){
    const m=ctx.match;

    if(m.phase==="claim"){
      const p=m.players[m.claimIndex];
      const taken=m.players.filter(x=>x.number!=null).map(x=>x.number);
      let opts = `<option value="" selected disabled>Select a numberâ€¦</option>`;
      for(let n=1;n<=20;n++){
        const dis=taken.includes(n) && p.number!==n;
        opts += `<option value="${n}" ${dis?"disabled":""}>${n}${dis?" (taken)":""}</option>`;
      }
      return `
        <div class="card"><div class="row">
          <button class="btn ghost" id="backToSetup">Back</button>
          <button class="btn danger" id="resetBtn">Reset</button>
        </div></div>

        <div class="card">
          <div class="h1">Killer Setup</div>
          <div class="sub">Claim your number (one at a time)</div>
          <div class="divider"></div>
          <div class="h1" style="font-size:22px;text-align:center;margin:0">${esc(p.name)}</div>
          <div class="sub" style="text-align:center">Pick the number you hit (opposite hand throw)</div>
          <div class="divider"></div>
          <select id="claimNum">${opts}</select>
          <div class="divider"></div>
          <button class="btn ok" id="saveClaim" type="button">Save & Next</button>
        </div>
      `;
    }

    const active=m.players[m.turnIndex];
    const isFinished=!!m.finished;

    const statusLine = isFinished
      ? `Winner: <b>${esc((m.winner && m.winner.name) || "")}</b>`
      : `${esc(active.name)} â€¢ Dart <b>${m.dartInTurn+1}</b>/3 â€¢ ${active.killer ? "ðŸ”¥ Killer" : "Not killer yet"}`;

    const rows = m.players.map(p=>{
      const livesHtml = p.out ? `<b>OUT</b>` : heartsHTML(p.lives);
      return `<div class="rosterCard">
        <div class="rosterLeft">
          <div class="avatar">${esc((p.name||"?").slice(0,1).toUpperCase())}</div>
          <div>
            <div style="font-weight:1000">${esc(p.name)}</div>
            <div class="small">Number: <b>${esc(p.number!=null?p.number:"?")}</b> â€¢ ${p.killer?"ðŸ”¥ Killer":""}</div>
          </div>
        </div>
        <div style="text-align:right">${livesHtml}</div>
      </div>`;
    }).join("");

    const canAttack = (!isFinished) && active.killer;
    const attackTargets = m.players
      .filter(p=>!p.out && p.email!==active.email)
      .map(p=>`<button class="btn" data-attack="${esc(p.email)}" ${canAttack?"":"disabled"}>
        HIT ${esc(p.name)}â€™s DOUBLE â†’ remove 1 life
      </button>`).join("");

    return `
      <div class="card"><div class="row">
        <button class="btn ghost" id="backToSetup">Back</button>
        <button class="btn danger" id="resetBtn">Reset</button>
      </div></div>

      <div class="card">
        <div class="row" style="align-items:center">
          <div><span class="pill">Killer</span> <span class="pill" data-live="1">${isFinished?"Ended":"Live"}</span></div>
          <div style="text-align:right" class="sub">${statusLine}</div>
        </div>

        ${isFinished ? "" : `<div id="turnNameBox" style="margin-top:10px">${turnNameHTML(m.players[m.turnIndex]?.name||"")}</div>`}

        ${isFinished ? "" : `
          <div class="divider"></div>
          <div class="row">
            <button class="btn ok" id="myDouble">I HIT MY DOUBLE</button>
            <button class="btn danger" id="miss">MISS</button>
            <button class="btn ghost" id="undoBtn">UNDO</button>
          </div>
          <div class="divider"></div>
          <div class="h1" style="font-size:16px;margin:0">Attack opponents</div>
          <div class="sub">Hit their double â†’ tap button to remove 1 life</div>
          <div class="divider"></div>
          <div class="stack">${attackTargets || `<div class="sub">No valid targets left.</div>`}</div>
        `}
      </div>

      <div class="card">
        <div class="h1" style="font-size:16px;margin:0;text-align:center">Players & Lives</div>
        <div class="divider"></div>
        <div class="stack">${rows}</div>
      </div>
    `;
  }

  function bindPlay(ctx){
    const m=ctx.match;
    try{ if(m.phase==="play" && !m.finished) animateTurnName("killer", m.players[m.turnIndex].name); }catch{}

    document.getElementById("backToSetup").onclick=()=>{ match=null; roomId=null; screen="game.setup"; render(); if(roomUnsub) try{roomUnsub();}catch{} };
    document.getElementById("resetBtn").onclick=()=>{
      const pls=m.players.map(p=>({name:p.name,email:p.email}));
      match=KillerGame.initMatch(pls); render(); if(roomId) saveMatchState(roomId, match).catch(()=>{});
    };

    const claimBtn=document.getElementById("saveClaim");
    if(claimBtn){
      claimBtn.onclick=()=>{
        const p=m.players[m.claimIndex];
        const raw=document.getElementById("claimNum").value;
        const n=parseInt(raw,10);
        if(!n){ alert("Pick a number."); return; }
        if(m.players.some(x=>x.email!==p.email && x.number===n)){ alert("That number is taken."); return; }
        p.number=n;

        let nextIdx=-1;
        for(let step=1; step<=m.players.length; step++){
          const i=(m.claimIndex+step)%m.players.length;
          if(m.players[i].number==null){ nextIdx=i; break; }
        }
        if(nextIdx===-1){
          m.phase="play"; m.turnIndex=0; m.dartInTurn=0;
          m.players.forEach(x=>{ x.out=false; x.killer=false; x.lives=MAX_LIVES; });
        }else{
          m.claimIndex=nextIdx;
        }
        render();
        if(roomId) saveMatchState(roomId, m).catch(()=>{});
      };
      return;
    }

    if(m.finished){ saveFinish(ctx).catch(()=>{}); return; }

    function pushK(m){ m.snaps=m.snaps||[]; m.snaps.push(JSON.stringify(m)); if(m.snaps.length>80) m.snaps.shift(); }
    function popK(m){
      if(!m || !m.snaps || m.snaps.length<2) return m;
      m.snaps.pop();
      const prev=m.snaps.pop();
      try{return JSON.parse(prev);}catch{return m;}
    }

    function endDart(){
      m.dartInTurn += 1;
      if(m.dartInTurn>=3){ m.dartInTurn=0; m.turnIndex = nextAliveIndex(m, m.turnIndex); }
      checkWinner(m);
      render();
      if(roomId) saveMatchState(roomId, m).catch(()=>{});
      if(m.finished){ saveFinish(ctx).catch(()=>{}); }
    }

    document.getElementById("undoBtn").onclick=()=>{ match=popK(ctx.match); render(); if(roomId) saveMatchState(roomId, match).catch(()=>{}); };
    document.getElementById("miss").onclick=()=>{ pushK(m); endDart(); };
    document.getElementById("myDouble").onclick=()=>{
      pushK(m);
      const me=m.players[m.turnIndex];
      if(me.number==null) return;
      if(!me.killer) me.killer=true;
      else me.lives = Math.min(MAX_LIVES, me.lives+1);
      endDart();
    };

    appEl.querySelectorAll("button[data-attack]").forEach(btn=>{
      btn.onclick=()=>{
        const me=m.players[m.turnIndex];
        if(!me.killer) return;
        const victimEmail=btn.getAttribute("data-attack");
        const victim=m.players.find(p=>p.email===victimEmail && !p.out);
        if(!victim) return;

        pushK(m);
        victim.lives -= 1;
        if(victim.lives<=0){ victim.lives=0; victim.out=true; }
        endDart();
      };
    });
  }

  return { initMatch, renderPlay, bindPlay };
})();

const AroundGame = (()=>{
  const TARGETS = Array.from({length:20},(_,i)=>i+1).concat(["B"]);
  const modeName = m => (m.mode==="D" ? "Doubles" : m.mode==="T" ? "Triples" : "Singles");

  function initMatch(selectedPlayers, mode){
    const m={
      gameId:"around",
      mode:(mode==="D"||mode==="T")?mode:"S",
      players:selectedPlayers.map(p=>({name:p.name,email:p.email,progressIndex:0,dartsThrown:0,hits:0})),
      turnIndex:0,dartInTurn:0,finished:false,winner:null,startedAt:now(),endedAt:null,snaps:[],_saved:false,_rev:0
    };
    pushSnap(m); return m;
  }
  function currentTarget(m,p){
    const idx=Math.min(p.progressIndex, TARGETS.length-1);
    return TARGETS[idx];
  }
  function finishIfDone(m,p){
    if(p.progressIndex>=TARGETS.length){
      m.finished=true; m.winner={name:p.name,email:p.email}; m.endedAt=now();
    }
  }
  function endDart(m){
    m.dartInTurn += 1;
    if(m.dartInTurn>=3){ m.dartInTurn=0; m.turnIndex=(m.turnIndex+1)%m.players.length; }
  }
  function addThrow(m, wasHit){
    if(!m || m.finished) return;
    const p=m.players[m.turnIndex];
    p.dartsThrown += 1;
    if(wasHit){ p.hits += 1; p.progressIndex += 1; finishIfDone(m,p); if(m.finished) return; }
    endDart(m);
  }

  async function saveFinish(ctx){
    const m=ctx.match;
    if(!m.finished || m._saved) return;
    m._saved=true;

    const winnerName=(m.winner&&m.winner.name)||"Unknown";
    const winnerRow=m.players.find(x=>x.email===(m.winner&&m.winner.email));
    const winnerDarts=winnerRow?winnerRow.dartsThrown:null;
    const summary = `ðŸ ${winnerName} wins â€¢ Format: ${modeName(m)}${winnerDarts!=null?` â€¢ ${winnerDarts} darts`:``}`;

    await saveHistoryEntry({
      gameId:"around", gameName:"Around the World",
      startedAt:m.startedAt, endedAt:m.endedAt,
      players:m.players.map(p=>p.email),
      summary,
      meta:{ mode:m.mode, winnerEmail:(m.winner&&m.winner.email)||null,
            darts:m.players.map(p=>({email:p.email, dartsThrown:p.dartsThrown, hits:p.hits})) }
    });

    const stats=await getStatsDoc(ctx.meUser.email);
    const games=stats.games||{};
    const g=games.around||{};
    const played=(g.played||0)+1;

    const meRow=m.players.find(p=>p.email===ctx.meUser.email);
    const myDarts=meRow?meRow.dartsThrown:0;
    const myHits=meRow?meRow.hits:0;

    const wins=(g.wins||0) + ((((m.winner && m.winner.email)===ctx.meUser.email)) ? 1 : 0);
    const totalDarts=(g.totalDarts||0)+myDarts;
    const totalHits=(g.totalHits||0)+myHits;

    let bestFewestDarts=g.bestFewestDarts??null;
    if(((m.winner && m.winner.email)===ctx.meUser.email)){
      if(bestFewestDarts==null || myDarts<bestFewestDarts) bestFewestDarts=myDarts;
    }

    await saveStatsDoc(ctx.meUser.email,{
      games:{...games, around:{...g, played, wins, totalDarts, totalHits, bestFewestDarts, lastPlayedAt:m.endedAt||now()}},
      updatedAt:now()
    });
  }

  function renderPlay(ctx){
    const m=ctx.match;
    const active=m.players[m.turnIndex];
    const t=currentTarget(m,active);
    const tLabel=(t==="B"?"BULL":String(t));
    const isFinished=!!m.finished;

    const statusLine = isFinished
      ? `Winner: <b>${esc((m.winner && m.winner.name) || "")}</b> â€¢ Format: <b>${esc(modeName(m))}</b>`
      : `Target: <b>${esc(tLabel)}</b> â€¢ Format: <b>${esc(modeName(m))}</b> â€¢ Dart <b>${m.dartInTurn+1}</b>/3`;

    const rows=m.players.map(p=>{
      const ct=currentTarget(m,p);
      const lbl=(ct==="B"?"BULL":String(ct));
      const acc=p.dartsThrown?Math.round((p.hits/p.dartsThrown)*100):0;
      return `<div class="rosterCard">
        <div class="rosterLeft">
          <div class="avatar">${esc((p.name||"?").slice(0,1).toUpperCase())}</div>
          <div>
            <div style="font-weight:1000">${esc(p.name)}</div>
            <div class="small">Current target: <b>${esc(lbl)}</b></div>
          </div>
        </div>
        <div style="text-align:right" class="small"><b>${esc(p.hits)}</b> hits / <b>${esc(p.dartsThrown)}</b> darts<br/>Acc: <b>${esc(acc)}%</b></div>
      </div>`;
    }).join("");

    return `
      <div class="card"><div class="row">
        <button class="btn ghost" id="backToSetup">Back</button>
        <button class="btn danger" id="resetBtn">Reset</button>
      </div></div>

      <div class="card">
        <div class="row" style="align-items:center">
          <div><span class="pill">Around the World</span> <span class="pill" data-live="1">${isFinished?"Ended":"Live"}</span></div>
          <div style="text-align:right" class="sub">${statusLine}</div>
        </div>

        ${isFinished ? "" : `<div id="turnNameBox" style="margin-top:10px">${turnNameHTML(m.players[m.turnIndex]?.name||"")}</div>`}

        <div class="divider"></div>
        <div style="display:flex;justify-content:center">${dartboardSVG(t==="B"?"B":t)}</div>
        ${playerStripHTML(m.players,m.turnIndex,(p)=>"Target: <b>"+esc((currentTarget(m,p)==="B")?"BULL":currentTarget(m,p))+"</b>")}
        <div class="divider"></div>

        ${isFinished ? "" : `
          <div class="row">
            <button class="btn ok" id="hitBtn">HIT</button>
            <button class="btn danger" id="missBtn">MISS</button>
            <button class="btn ghost" id="undoBtn">UNDO</button>
          </div>
        `}
      </div>

      <div class="card">
        <div class="h1" style="font-size:16px;margin:0;text-align:center">Players</div>
        <div class="divider"></div>
        <div class="stack">${rows}</div>
      </div>
    `;
  }

  function bindPlay(ctx){
    try{ animateTurnName("around", ctx.match.players[ctx.match.turnIndex].name); }catch{}
    const m=ctx.match;

    document.getElementById("backToSetup").onclick=()=>{ match=null; roomId=null; screen="game.setup"; render(); if(roomUnsub) try{roomUnsub();}catch{} };
    document.getElementById("resetBtn").onclick=()=>{
      const pls=m.players.map(p=>({name:p.name,email:p.email}));
      match=AroundGame.initMatch(pls, m.mode); render(); if(roomId) saveMatchState(roomId, match).catch(()=>{});
    };

    if(m.finished){ saveFinish(ctx).catch(()=>{}); return; }

    const undoBtn=document.getElementById("undoBtn");
    if(undoBtn) undoBtn.onclick=()=>{ match=popSnap(ctx.match); render(); if(roomId) saveMatchState(roomId, match).catch(()=>{}); };

    const hitBtn=document.getElementById("hitBtn");
    if(hitBtn) hitBtn.onclick=()=>{
      pushSnap(m); addThrow(m,true); render(); if(roomId) saveMatchState(roomId, m).catch(()=>{});
      if(m.finished) saveFinish(ctx).catch(()=>{});
    };

    const missBtn=document.getElementById("missBtn");
    if(missBtn) missBtn.onclick=()=>{
      pushSnap(m); addThrow(m,false); render(); if(roomId) saveMatchState(roomId, m).catch(()=>{});
      if(m.finished) saveFinish(ctx).catch(()=>{});
    };
  }

  return { initMatch, renderPlay, bindPlay };
})();

/* ========= Render routing ========= */
window.__rendering = false;
window.__renderAgain = false;

function requestRender(reason){
  if(window.__rendering){ window.__renderAgain=true; return; }
  render();
}

     if(soundBtn){
       soundBtn.onclick=()=>{
         try{ unlockAudio(); }catch{}
         const wasOn = !!soundEnabled;
         if(wasOn) playBeep('toggle');
    async function renderAuth(){
  signOutBtn.style.display="none";
  brandTitle.textContent="Game Night";

  let html = `${toastMsg?`<div class="toast">${esc(toastMsg)}</div>`:""}`;
  toastMsg="";

  html += `
    <div class="card">
      <div class="row" style="align-items:center">
        <div class="logoMark"><span>ðŸŽ¯</span></div>
        <div style="flex:3">
          <div class="h1">Game Night</div>
          <div class="sub">Sign in with your email. Your stats and history are stored online.</div>
        </div>
        <div style="text-align:right"><span class="pill">v63</span></div>
      </div>
    </div>

    <div class="card">
      <label>Email</label>
      <div class="stack">
        <input id="inEmail" type="email" placeholder="you@email.com" autocomplete="email"/>
        <button class="btn ok" id="goBtn">Enter</button>
      </div>
    </div>
  
     <div class="brandLogoWrap">
       <div class="loginArtSvg" aria-hidden="true">
<svg viewBox="0 0 900 260" width="100%" height="100%" preserveAspectRatio="xMidYMid meet" xmlns="http://www.w3.org/2000/svg">
  <defs>
    <linearGradient id="gnTitle" x1="0" y1="0" x2="1" y2="0">
      <stop offset="0" stop-color="#22d3ee"/>
      <stop offset="0.55" stop-color="#3b82f6"/>
      <stop offset="1" stop-color="#22d3ee"/>
    </linearGradient>
    <radialGradient id="gnHalo" cx="50%" cy="45%" r="70%">
      <stop offset="0" stop-color="rgba(34,211,238,0.22)"/>
      <stop offset="0.55" stop-color="rgba(59,130,246,0.10)"/>
      <stop offset="1" stop-color="rgba(6,8,20,0)"/>
    </radialGradient>
    <filter id="gnGlow" x="-30%" y="-30%" width="160%" height="160%">
      <feGaussianBlur stdDeviation="6" result="b"/>
      <feColorMatrix in="b" type="matrix"
        values="0 0 0 0 0.13  0 0 0 0 0.83  0 0 0 0 0.93  0 0 0 1 0" result="c"/>
      <feMerge><feMergeNode in="c"/><feMergeNode in="SourceGraphic"/></feMerge>
    </filter>
    <!-- Fade edges + bottom so it blends into the page -->
    <linearGradient id="fadeBottom" x1="0" y1="0" x2="0" y2="1">
      <stop offset="0" stop-color="white" stop-opacity="1"/>
      <stop offset="0.72" stop-color="white" stop-opacity="1"/>
      <stop offset="1" stop-color="white" stop-opacity="0"/>
    </linearGradient>
    <mask id="gnMask">
      <rect x="0" y="0" width="900" height="260" fill="url(#fadeBottom)"/>
    </mask>
  </defs>

  <g mask="url(#gnMask)">
    <rect x="0" y="0" width="900" height="260" fill="transparent"/>
    <ellipse cx="450" cy="128" rx="420" ry="170" fill="url(#gnHalo)"/>
    <!-- Subtle dartboard ring hint -->
    <g opacity="0.55" filter="url(#gnGlow)">
      <circle cx="450" cy="132" r="92" fill="none" stroke="rgba(34,211,238,0.35)" stroke-width="5"/>
      <circle cx="450" cy="132" r="58" fill="none" stroke="rgba(59,130,246,0.22)" stroke-width="4"/>
      <circle cx="450" cy="132" r="26" fill="none" stroke="rgba(34,211,238,0.22)" stroke-width="4"/>
    </g>

    <text x="450" y="128" text-anchor="middle"
      font-family="system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif"
      font-size="56" font-weight="1000"
      fill="url(#gnTitle)" filter="url(#gnGlow)"
      style="letter-spacing:1px">The Dart Room</text>

    <text x="450" y="166" text-anchor="middle"
      font-family="system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif"
      font-size="18" font-weight="900"
      fill="rgba(238,244,255,0.80)"
      style="letter-spacing:0.6px">Night Games</text>
  </g>
</svg>
</div>
     </div>
`;
  setHTML(html);

  document.getElementById("goBtn").onclick = async()=>{
    const e = normEmail(document.getElementById("inEmail").value);
    if(!e){ toastMsg="Enter a valid email."; return render(); }
    const player = await signInEmail(e);
    if(player){
      meUser=player;
      startPresence(meUser.email, meUser.name);
      screen="home";
      return render();
    }
    meUser={email:e};
    screen="signup";
    render();
  };
}

.getElementById("inEmail").value);
    if(!e){ toastMsg="Enter a valid email."; return render(); }
    const player = await signInEmail(e);
    if(player){
      meUser=player;
      startPresence(meUser.email, meUser.name);
      screen="home";
      return render();
    }
    meUser={email:e};
    screen="signup";
    render();
  };
}

async function renderSignup(){
  signOutBtn.style.display="none";
  brandTitle.textContent="Game Night";

  setHTML(`
    <div class="card">
      <div class="row" style="align-items:center">
        <div class="logoMark"><span>ðŸ§¾</span></div>
        <div>
          <div class="h1">Create Player</div>
          <div class="sub">Just your name â€” youâ€™re in.</div>
        </div>
      </div>
    </div>

    <div class="card">
      <label>Name</label>
      <div class="stack">
        <input id="upName" type="text" placeholder="Your Name" autocomplete="name"/>
        <button class="btn ok" id="createBtn">Create</button>
        <button class="btn ghost" id="backBtn">Back</button>
      </div>
    </div>
  `);

  document.getElementById("backBtn").onclick=()=>{ meUser=null; screen="auth"; render(); };
  document.getElementById("createBtn").onclick=async()=>{
    const n=String(document.getElementById("upName").value).trim();
    if(!n){ toastMsg="Enter your name."; return render(); }
    meUser = await signUpEmail(n, meUser.email);
    startPresence(meUser.email, meUser.name);
    screen="home";
    render();
  };
}

function initials(name){
  const n=String(name||"").trim();
  if(!n) return "?";
  const parts=n.split(/\s+/).filter(Boolean);
  const a=((parts[0] && parts[0][0]) || "").toUpperCase();
  const b=((parts[1] && parts[1][0]) || "").toUpperCase();
  return (a+(b||"")).slice(0,2) || a || "?";
}

async function renderHome(){
  signOutBtn.style.display="inline-block";
  brandTitle.textContent="Game Night";

  const players = await getPlayers();

  const gameCards = Games.map(g=>{
    const soon=!g.active;
    return `
      <div class="gameCard">
        <div class="gameHead">
          <div class="gameTitle">
            <div class="gameIcon">${esc(g.icon||"ðŸŽ¯")}</div>
            <div>
              <div class="h1" style="font-size:18px;margin:0">${esc(g.name)}</div>
              <div class="gameMeta">${esc(g.tagline||"")}</div>
            </div>
          </div>
          <div>${soon?`<span class="pill soon">Coming soon</span>`:`<span class="pill" data-live="1">Active</span>`}</div>
        </div>
        <div class="gameActions">
          <button class="btn ok" data-play="${esc(g.id)}" ${soon?"disabled":""}>Play</button>
          <button class="btn ghost" data-stats="${esc(g.id)}">Stats</button>
        </div>
      </div>
    `;
  }).join("");

  const roster = players
     .slice()
     .sort((a,b)=> (a.email===meUser.email?-1:0) - (b.email===meUser.email?-1:0))
     .map(p=>`
       <div class="rosterCard">
         <div class="rosterLeft">
           <div class="avatar ${isOnline(p.email)?"online":""}">${esc(initials(p.name))}</div>
           <div class="rosterText">
             <div class="rosterName">${esc(p.name)}${p.email===meUser.email?` <span class="badge">YOU</span>`:""}</div>
             <div class="rosterSub">${esc(p.email)}</div>
           </div>
         </div>
         <div style="display:flex;gap:8px;align-items:center;justify-content:flex-end;flex-wrap:wrap">
           <button class="btn ghost" data-view-player="${esc(p.email)}">Stats</button>
           <button class="btn danger" data-del-player="${esc(p.email)}" ${p.email===meUser.email?"disabled":""}>Remove</button>
         </div>
       </div>
     `).join("");

  setHTML(`
    <div class="card">
      <div class="row" style="align-items:center;gap:12px">
        
        <div style="min-width:0">
          <div class="h1" style="margin:0;font-size:18px">${esc(meUser.name||"Player")}</div>
          <div class="sub">${esc(meUser.email)}</div>
        </div>
      </div>
      <div class="divider"></div>
</div>

    <div class="row">
      <button class="btn ghost" id="statsBtn">Stats</button>
      <button class="btn ghost" id="historyBtn">History</button>
    </div>

    <div class="divider"></div>
    <div class="gameGrid">${gameCards}</div>

    <div class="divider"></div>

    <div class="card">
      <div class="h1" style="text-align:center;margin:0">Players</div>
      <div class="sub" style="text-align:center">Green dot means theyâ€™re online (heartbeat via Firebase).</div>
      <div class="divider"></div>
      <div class="rosterGrid">${roster || `<div class="sub">No players yet.</div>`}</div>
    </div>
  `);
   // ===== Home avatar (only for signed-in user) =====
  document.getElementById("statsBtn").onclick = ()=>{ screen="stats"; render(); };
  document.getElementById("historyBtn").onclick = ()=>{ screen="history"; render(); };

  appEl.querySelectorAll("button[data-play]").forEach(btn=>{
    btn.onclick = ()=>{
      activeGameId = btn.getAttribute("data-play");
      match=null;
      screen="game.setup";
      render();
    };
  });
  appEl.querySelectorAll("button[data-stats]").forEach(btn=>{
    btn.onclick = ()=>{
      activeGameId = btn.getAttribute("data-stats");
      screen="stats.game";
      render();
    };
  });

  // Player (person) stats + delete actions
  appEl.querySelectorAll('button[data-view-player]').forEach(btn=>{
    btn.onclick=()=>{
      statsViewerEmail = btn.getAttribute("data-view-player");
      screen = "stats";
      render();
    };
  });

  appEl.querySelectorAll('button[data-del-player]').forEach(btn=>{
    btn.onclick=async()=>{
      const email = btn.getAttribute("data-del-player");
      if(!email) return;
      const p = players.find(x=>x.email===email);
      const name = (p && p.name) || email;
      if(normEmail(email)===normEmail(meUser.email)){
        toastMsg="You canâ€™t remove yourself while signed in.";
        return render();
      }
      if(!confirm(`Remove ${name}? This deletes the player, their stats, and their history.`)) return;
      try{
        await deletePlayerAndData(email);
        toastMsg=`Removed ${name}.`;
        render();
      }catch(e){
        showFatal("Delete error", (e && e.message) || String(e));
      }
    };
  });

}

function updateSetupUI(){
  const selectedCountEl = document.getElementById("selectedCount");
  const hintLine = document.getElementById("hintLine");
  const startBtn = document.getElementById("startMatchBtn");
  if(!selectedCountEl || !hintLine || !startBtn) return;

  selectedCountEl.value = `${setupSelectedEmails.length} / ${setupWantedCount}`;
  const g = getGame(activeGameId);
  const ok = (setupSelectedEmails.length === setupWantedCount) && g && g.active;
  startBtn.disabled = !ok;
  hintLine.textContent = !g?.active ? "This game is coming soon." : ok ? "Ready." : `Select exactly ${setupWantedCount} players to continue.`;
}

async function renderGameSetup(){
  const g = getGame(activeGameId);
  if(!g){ screen="home"; return render(); }

  signOutBtn.style.display="inline-block";
  brandTitle.textContent=g.name;

  setupPlayersAll = await getPlayers();

  // Default selection: none (user picks)
  setupWantedCount = 2;
  setupSelectedEmails = [];

  // Auto-join if I'm already in a waiting/active room for this game
  try{
    const existing = await findWaitingRoomForPlayer(activeGameId, meUser.email);
    if(existing){
      roomId = existing;
      await joinRoom(roomId);
      roomHost = false;
      roomSynced = false;
      screen="game.play";
      return render();
    }
  }catch(e){ /* ignore */ }

  const aroundModeUI = (activeGameId==="around" && g.active) ? `
    <div class="divider"></div>
    <label>Format (Singles / Doubles / Triples)</label>
    <select id="aroundMode">
      <option value="S" selected>Singles</option>
      <option value="D">Doubles</option>
      <option value="T">Triples</option>
    </select>
    <div class="small">Pick the format before starting.</div>
  ` : "";

  setHTML(`
    <div class="card"><div class="row">
      <button class="btn ghost" id="setupBack">Back</button>
    </div></div>

    <div class="card">
      <div class="row" style="align-items:center">
        <div class="logoMark"><span>${esc(g.icon||"ðŸŽ¯")}</span></div>
        <div style="flex:3">
          <div class="h1">${esc(g.name)}</div>
          <div class="sub">Pick players (max ${MAX_PLAYERS}).</div>
        </div>
        <div style="text-align:right">${g.active?`<span class="pill" data-live="1">Ready</span>`:`<span class="pill soon">Coming soon</span>`}</div>
      </div>
    </div>

    <div class="card">
      <div class="stack">
        <div class="row">
          <div>
            <label>Number of players</label>
            <select id="playerCount">
              ${Array.from({length:MAX_PLAYERS},(_,i)=>i+1).map(n=>`<option value="${n}" ${n===2?"selected":""}>${n}</option>`).join("")}
            </select>
          </div>
          <div>
            <label>Selected</label>
            <input id="selectedCount" type="text" value="" disabled />
          </div>
        </div>

        <button class="btn" id="openPickerBtn">Select players (dropdown)</button>
        <div class="small" id="selectedNames"></div>

        ${aroundModeUI}

        <button class="btn ok" id="startMatchBtn">Start Match</button>
        <div class="sub" id="hintLine"></div>
      </div>
    </div>
  `);

  const playerCountEl = document.getElementById("playerCount");
  playerCountEl.onchange = ()=>{
    setupWantedCount = parseInt(playerCountEl.value,10) || 2;
    // Trim if too many
    setupSelectedEmails = setupSelectedEmails.slice(0, setupWantedCount);
    updateSelectedNames();
    updateSetupUI();
  };

  document.getElementById("openPickerBtn").onclick = openPicker;
  document.getElementById("setupBack").onclick = ()=>{ activeGameId=null; match=null; roomId=null; screen="home"; render(); };

  function updateSelectedNames(){
    const names = setupSelectedEmails
      .map(e=>setupPlayersAll.find(p=>normEmail(p.email)===normEmail(e))?.name || e);
    document.getElementById("selectedNames").textContent = names.length ? `Selected: ${names.join(", ")}` : "";
  }
  window.updateSelectedNames = updateSelectedNames;
  updateSelectedNames();
  updateSetupUI();

  document.getElementById("startMatchBtn").onclick = async()=>{
    if(!g.active){ toastMsg="Coming soon."; return render(); }
    if(setupSelectedEmails.length !== setupWantedCount){
      toastMsg = `Select exactly ${setupWantedCount} players.`;
      return render();
    }

    const selectedPlayers = setupSelectedEmails
      .map(e=>setupPlayersAll.find(p=>normEmail(p.email)===normEmail(e)))
      .filter(Boolean);

    // Create multiplayer room + lock
    roomHost = true;
    roomId = await createRoom(activeGameId, selectedPlayers.map(p=>p.email));
    await joinRoom(roomId); // puts state active if needed

    // Start local match + write initial matchData (host)
    if(activeGameId==="shanghai") match = ShanghaiGame.initMatch(selectedPlayers);
    else if(activeGameId==="killer") match = KillerGame.initMatch(selectedPlayers);
    else if(activeGameId==="around"){
      const modeEl = document.getElementById("aroundMode");
      const mode = modeEl ? modeEl.value : "S";
      match = AroundGame.initMatch(selectedPlayers, mode);
    }else{
      toastMsg="Coming soon."; return render();
    }

    // Initial sync
    try{ await saveMatchState(roomId, match); }catch{}
    screen="game.play";
    render();
  };
}

async function renderGamePlay(){
  const g=getGame(activeGameId);
  if(!g){ screen="home"; return render(); }

  signOutBtn.style.display="inline-block";
  brandTitle.textContent=g.name;

  // Multiplayer: subscribe to room state and matchData
  if(roomId){
    listenMatchState(roomId, (roomDoc)=>{
      // Security: only allow if I'm listed
      const plist = Array.isArray(roomDoc.players)?roomDoc.players:[];
      if(!plist.includes(normEmail(meUser.email))) return;

      // If matchData exists and it's newer than ours, adopt it
      if(roomDoc.matchData){
        const incoming = roomDoc.matchData;
        const inRev = Number(roomDoc.rev||0);
        const myRev = Number(match?match._rev||0:0);
        const updatedBy = normEmail(roomDoc.updatedBy || "");
        const me = normEmail(meUser.email);

        // Accept if: we have no match yet, or it's newer and not just our echo
        if(!match || (inRev > myRev && updatedBy !== me)){
          match = incoming;
          roomSynced = true;
          requestRender("roomSync");
        }
      }else{
        // If host and no matchData yet, write it
        if(roomHost && match){
          saveMatchState(roomId, match).catch(()=>{});
        }
      }
    });
  }

  if(!match){
    setHTML(`<div class="card"><div class="h1">Waitingâ€¦</div><div class="sub">Joining the match roomâ€¦</div></div>`);
    // If not host, we wait for host to publish matchData
    return;
  }

  const ctx={meUser, match};

  if(activeGameId==="shanghai"){
    setHTML(ShanghaiGame.renderPlay(ctx));
    ShanghaiGame.bindPlay(ctx);
    return;
  }
  if(activeGameId==="killer"){
    setHTML(KillerGame.renderPlay(ctx));
    KillerGame.bindPlay(ctx);
    return;
  }
  if(activeGameId==="around"){
    setHTML(AroundGame.renderPlay(ctx));
    AroundGame.bindPlay(ctx);
    return;
  }
  screen="home"; render();
}

async function renderStats(){
  signOutBtn.style.display="inline-block";
  brandTitle.textContent="Stats";

  const players=await getPlayers();
  const viewerEmail = meUser.email;

  const statsDoc = await getStatsDoc(viewerEmail);
  const games = statsDoc.games || {};

  function aroundLine(gs){
    const played=gs.played||0, wins=gs.wins||0, td=gs.totalDarts||0, th=gs.totalHits||0;
    const acc=td?Math.round((th/td)*100):0;
    const best=gs.bestFewestDarts!=null?gs.bestFewestDarts:"â€”";
    return `Played: <b>${played}</b> â€¢ Wins: <b>${wins}</b> â€¢ Accuracy: <b>${acc}%</b> â€¢ Best: <b>${esc(best)}</b>`;
  }

  setHTML(`
    <div class="card">
      <div class="h1" style="text-align:center;margin:0">Stats</div>
      <div class="sub" style="text-align:center">Stored online (Firebase) â€¢ Everyone can view everyoneâ€™s stats.</div>
      <div class="divider"></div>
      <div class="sub">Viewing: <b>${esc(meUser.name||"Player")}</b></div>
      <div class="divider"></div>
      <div class="row">
        <button class="btn danger" id="resetAllStatsBtn">Reset my stats</button>
        <button class="btn ghost" id="statsBack">Back</button>
      </div>
    </div>

    ${Games.map(g=>{
      const gs=games[g.id]||{};
      const played=gs.played||0;
      const line =
        g.id==="shanghai" ? `Played: <b>${played}</b> â€¢ Best: <b>${esc(gs.best||0)}</b> â€¢ Points: <b>${esc(gs.points||0)}</b>` :
        g.id==="killer"   ? `Played: <b>${played}</b> â€¢ Wins: <b>${esc(gs.wins||0)}</b>` :
        g.id==="around"   ? aroundLine(gs) :
        (g.active ? `Played: <b>${played}</b>` : `Coming soon`);
      return `
        <div class="gameCard">
          <div class="gameHead">
            <div class="gameTitle">
              <div class="gameIcon">${esc(g.icon||"ðŸŽ¯")}</div>
              <div>
                <div class="h1" style="font-size:18px;margin:0">${esc(g.name)}</div>
                <div class="gameMeta">${line}</div>
              </div>
            </div>
            <button class="btn ghost" data-open="${esc(g.id)}">Open</button>
          </div>
        </div>
      `;
    }).join("")}
  `);

  document.getElementById("statsBack").onclick=()=>{ screen="home"; render(); };
  document.getElementById("resetAllStatsBtn").onclick=async()=>{
    if(!confirm("Reset ALL your stats?")) return;
    await resetStatsAll(meUser.email);
    toastMsg="Stats reset.";
    render();
  };

  appEl.querySelectorAll("button[data-open]").forEach(btn=>{
    btn.onclick=()=>{ activeGameId=btn.getAttribute("data-open"); screen="stats.game"; render(); };
  });
}

async function renderStatsGame(){
  const g=getGame(activeGameId);
  if(!g){ screen="stats"; return render(); }
  signOutBtn.style.display="inline-block";
  brandTitle.textContent=`${g.name} â€¢ Stats`;

  const statsDoc = await getStatsDoc(meUser.email);
  const gs=(statsDoc.games||{})[g.id]||{};

  let body="";
  if(g.id==="shanghai"){
    body=`
      <div class="sub">Played: <b>${esc(gs.played||0)}</b></div>
      <div class="sub">Points: <b>${esc(gs.points||0)}</b></div>
      <div class="sub">Best game: <b>${esc(gs.best||0)}</b></div>
      <div class="sub">Last played: <b>${esc(gs.lastPlayedAt?fmt(gs.lastPlayedAt):"â€”")}</b></div>
    `;
  }else if(g.id==="killer"){
    body=`
      <div class="sub">Played: <b>${esc(gs.played||0)}</b></div>
      <div class="sub">Wins: <b>${esc(gs.wins||0)}</b></div>
      <div class="sub">Last played: <b>${esc(gs.lastPlayedAt?fmt(gs.lastPlayedAt):"â€”")}</b></div>
    `;
  }else if(g.id==="around"){
    const played=gs.played||0, wins=gs.wins||0, td=gs.totalDarts||0, th=gs.totalHits||0;
    const acc=td?Math.round((th/td)*100):0;
    const best=gs.bestFewestDarts!=null?gs.bestFewestDarts:"â€”";
    body=`
      <div class="sub">Played: <b>${esc(played)}</b></div>
      <div class="sub">Wins: <b>${esc(wins)}</b></div>
      <div class="sub">Total darts: <b>${esc(td)}</b></div>
      <div class="sub">Total hits: <b>${esc(th)}</b></div>
      <div class="sub">Accuracy: <b>${esc(acc)}%</b></div>
      <div class="sub">Best (fewest darts to win): <b>${esc(best)}</b></div>
      <div class="sub">Last played: <b>${esc(gs.lastPlayedAt?fmt(gs.lastPlayedAt):"â€”")}</b></div>
    `;
  }else{
    body=g.active?`<div class="sub">Played: <b>${esc(gs.played||0)}</b></div>`:`<div class="sub">Coming soon.</div>`;
  }

  setHTML(`
    <div class="card">
      <div class="h1">${esc(g.name)} stats</div>
      ${body}
      <div class="divider"></div>
      <div class="row">
        <button class="btn danger" id="resetGameStatsBtn">Reset this game</button>
        <button class="btn ghost" id="statsGameBack">Back</button>
      </div>
    </div>
  `);

  document.getElementById("statsGameBack").onclick=()=>{ screen="stats"; render(); };
  document.getElementById("resetGameStatsBtn").onclick=async()=>{
    if(!confirm(`Reset ${g.name} stats?`)) return;
    await resetStatsGame(meUser.email, g.id);
    toastMsg=`${g.name} stats reset.`;
    render();
  };
}

async function renderHistory(){
  signOutBtn.style.display="inline-block";
  brandTitle.textContent="History";

  const history=await getHistory(meUser.email);
  let items=history.map(h=>`
    <div class="card">
      <div class="h1" style="font-size:16px;margin:0">${esc(h.summary||"(no summary)")}</div>
      <div class="sub">${esc(h.gameName||h.gameId||"Game")} â€¢ ${esc(h.endedAt?fmt(h.endedAt):"")}</div>
    </div>
  `).join("");
  if(!items) items=`<div class="card"><div class="sub">No matches yet.</div></div>`;

  setHTML(`
    <div class="row">
      <button class="btn ghost" id="historyBack">Back</button>
    </div>
    <div class="divider"></div>
    ${items}
  `);

  document.getElementById("historyBack").onclick=()=>{ screen="home"; render(); };
}

async function render(){
  if(window.__rendering){ window.__renderAgain=true; return; }
  window.__rendering=true;
  try{
    if(screen==="auth") return renderAuth();
    if(screen==="signup") return renderSignup();
    if(!meUser){ screen="auth"; return renderAuth(); }

    // keep player profile fresh
    if(meUser.email && meUser.name) upsertPlayer(meUser.name, meUser.email).catch(()=>{});

    if(screen==="home") return renderHome();
    if(screen==="game.setup") return renderGameSetup();
    if(screen==="game.play") return renderGamePlay();
    if(screen==="stats") return renderStats();
    if(screen==="stats.game") return renderStatsGame();
    if(screen==="history") return renderHistory();

    screen="home"; return renderHome();
  }catch(e){
    setHTML(`<div class="card"><div class="h1">App error</div><div class="sub">${esc(e?.message||String(e))}</div></div>`);
  }finally{
    window.__rendering=false;
    if(window.__renderAgain){ window.__renderAgain=false; render(); }
  }
}

render();
</script>
</body>
</html>
